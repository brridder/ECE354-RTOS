\documentclass[oneside]{report}
\usepackage{listings}
\usepackage[hmargin=1.4in,vmargin=1.0in]{geometry}
\usepackage[T1]{fontenc}
\usepackage[latin1]{inputenc}
\usepackage{float}
\begin{document}
\lstset{language=C, 
        frame=single, 
        breaklines=true,
        basicstyle=\small\ttfamily,
        columns=fullflexible}

% Pre-amble - title

\title{ECE354: RTX Project Final Report}
\author{Ben Ridder - brridder \\
Casey Banner - cccbanne \\
David Janssen - dajjanss }
\date{\today}

\maketitle

\tableofcontents
\listoftables
\lstlistoflistings

\chapter{\textsc{Software Design}}

\section{\textsc{Introduction}}

\section{\textsc{Global Information}}
% Data structures (queues, PCB, message formats, tracebuffer, etc)
% Variables
% Constants (PIDS, msgID, return codes, status codes, msg types, etc)
% Stacks
% Memory map
% Priority Queue

% TODO :: priority queues

Within the RTX system, there are several pieces of information available
globally within all contexts and several that are exposed only within kernel
mode. Certain data structures, such as the message envelope, are used by
user processes. Whereas other structures are used strictly by the kernel. 
Several global variables are available for certain use cases. Constants are used 
to define priority levels, IDs, and more. Stack usage is limited to standard
function uses, storing states before switching contexts, and for process
switching. Memory mapping is handled with a free list paired with an allocation
bit field for control.

\subsection{\textsc{Data Structures}}
The global data structures available have been split up into two categories:
user mode and kernel mode structures. This has been done to differentiate
between what is normally accessible in each context.

\subsubsection{\textsc{User Level}}
In user level mode there is one data structure available to the programmer
which is also available in kernel mode. This is the message envelope used to
send and receive messages between processes. It contains sender and receiver
process ids, the message type, pointers to the next and previous messages when
it is enqueued, values to control delay sending, and a data field defined at
the last 64 bytes of the envelope. The message type is defined in
Section~\ref{sec:global_constants}. To the user the only fields that are
modifiable in any meaningful way are the message type and data. All of the
other fields are modified by the kernel when the message is sent to another
process. If the user does not need to set the message type then this data
structure is not necessary as the only knowledge required for message sending
is that the data resides at an offset of 64 bits. In this case, the message
envelope is strictly used by the kernel. The message envelope definition can be
seen in Table~\ref{user_data_structs}.

\begin{table}[H]
    \caption{User Level Data Structure}
    \label{user_data_structs}
    \center{
    \begin{tabular}{| l | p{8cm} |}
        \hline
        Structure & Definition \\
        \hline
        Message Envelope &
\begin{verbatim}
int sender_pid
int receiver_pid
enum message_type type
struct message_envelope* next
struct message_envelope* previous
int delay
int delay_start
unsigned char padding[36]
unsigned char data[64]
\end{verbatim} \\
        \hline
    \end{tabular}
    } % Center
\end{table}

\subsubsection{\textsc{Kernel Level}}
There are several kernel level data structures which includes the process
control block, two queues, and a debug message envelope. The process control
block contains all the information required by the system to manage and
schedule the process. Both queues are implemented with a double linked list to
ensure $O(1)$ operation for both popping off the head and pushing to the tail.
Message queue is used for storing message envelopes associated with a specific
process. The process queue is used for the priority queues. The structures are
defined in Table~\ref{kernel_data_structs}

\begin{table}[H]
    \caption{Kernel Level Data Structures}
    \label{kernel_data_structs}
    \center{
    \begin{tabular}{| l | p{8cm} |}
    \hline
    Structure & Definition \\
    \hline
    Process Control Block &
\begin{verbatim}
int pid
int priority
void* stack
int stack_size
void (*entry)()
bool is_i_process
enum process_state state
enum queue_type queue
message_queue messages
struct process_control_block* next
struct process_control_block* previous
\end{verbatim} \\

    \hline
    Message Queue & 
\begin{verbatim}
message_envelope* head
message_envelope* tail
\end{verbatim} \\
    \hline

    Process Queue &
\begin{verbatim}
process_control_block* head 
process_control_block* tail 
\end{verbatim} \\
    \hline

    Debug Message Envelope &
\begin{verbatim}
int sender_pid
int receiver_pid
enum message_type type
unsigned char data[16]
int time_stamp
\end{verbatim} \\
    \hline

    \end{tabular}
    } % Center
\end{table}

% Stacks
% Memory map
% Priority Queue

\subsection{\textsc{Variables}}
Within the kernel, there are several variables that are used for various
components. For memory, there is a pointer to the head of the free list, a bit
field for determining memory allocations, and a pointer to the end of free
memory. Several process queues are used for containing the ready, blocked on
message, and blocked on memory processes in FIFO order. These are stored in an
array of process queues to generalize queue operations. If debugging hot keys
are enabled, then two circular buffers for the last ten recently sent and
received messages are available in the kernel. Finally, a counter used for
timing is incremented by the timer ISR and read by various kernel functions.

\subsection{\textsc{Constants}}
\label{sec:global_constants}

% TODO :: Add more?

% Constants (PIDS, msgID, return codes, status codes, msg types, etc)

All of the processes have a predefined process ID as outlined in
Table~\ref{table_proc_ids}. There is a total of 15 unique processes and there
is no capability to add extra processes while executing. 

\begin{table}[H]
    \caption{Process IDs}    
    \label{table_proc_ids}
    \center{
    \begin{tabular}{| r | c || r | c |}
    \hline
    Process & Process ID & Process & Process ID \\
    \hline
    \hline 
    \texttt{Null Process} & 0 & \texttt{User Process B} & 8 \\
    \texttt{Test Process 1} & 1 & \texttt{User Process C} & 9 \\
    \texttt{Test Process 2} & 2 & \texttt{UART Interrupt Process} & 10 \\
    \texttt{Test Process 3} & 3 & \texttt{Timer Interrupt Process} & 11 \\ 
    \texttt{Test Process 4} & 4 & \texttt{CRT Display Process} & 12 \\
    \texttt{Test Process 5} & 5 & \texttt{KCD Process} & 13 \\
    \texttt{Test Process 6} & 6 & \texttt{Wall Clock Process} & 14 \\
    \texttt{User Process A} & 7 & \texttt{Set Priority Process} & 15 \\
    \hline
    \end{tabular}
    } % Center
\end{table}

There are six message types defined using an enumerator available to the
processes for specific duties. See Table~\ref{table_msg_types} for the type
name, process, and description of each type.

\begin{table}[H]
    \caption{Message Types}
    \label{table_msg_types}
    \center{
    \begin{tabular}{| r | r | p{5cm} |}
    \hline
    Message Type & Receiving Process & Description \\
    \hline
    \hline
    \texttt{MESSAGE\_CMD\_REG} & KCD Process & Used to register the command
    sequence in the data field. \\
    \texttt{MESSAGE\_KEY\_INPUT} & KCD Process & The data field contains a
    command string that is interpretted and forwarded to the registered
    process. \\
    \texttt{MESSAGE\_OUTPUT} & CRT Display Process & The data field contains
    a string to output to the display. \\ 
    \texttt{MESSAGE\_OUTPUT\_NO\_NEWLINE} & CRT Display Process & The data
    field contains a string to output to the display but does not include a
    newline. Used by the wall clock process. \\
    \texttt{MESSAGE\_COUNT\_REPORT} & User Process C & The data field contains
    the current count from User Process A. \\
    \texttt{MESSAGE\_WAKE\_UP\_10} & User Process C & Sent on a delay of 10
    seconds to alert User Process C to wake up and continue. \\
    \hline
    \end{tabular}
    } % Center

\end{table}

Two return codes are used by functions in the system. The first,
\texttt{RTX\_SUCCESS}, and is defined as $0$ is used for indicating sucess. The
other, \texttt{RTX\_ERROR}, is defined as $-1$ and is used for indicating failure.
This maintains consistency between different functions and makes the code more
readable for checking return conditions.

\subsection{\textsc{Stacks}}

The only stacks used in the system are the process stacks. These are used for
storing and restoring the process state when making a mode switch and for
switching processes. The stacks are also used for allocation of local variables
and function calls as determined by the compiler.

\subsection{\textsc{Memory}}
\label{sec:mem_management}
The memory system consists of two components that are managed by the request
and release memory block primitives. The first is a free list containing a
total of 32 128-byte memory blocks. Each memory block is linked together using
the first word as the pointer to the next block of memory. When a block is
requested, the head is sent to the requestor and the new head becomes the
memory location that the old one pointed to. Putting a block back onto the free
list requires setting the first word of the block to the pointer of the current
head and the new head is now that block. The benefit to this approach is that
the blocks can be returned onto the free list in any order without affecting
the operation of this data structure. All free list operations are done in
$O(1)$ time.

The other component is a bit field. Since only 32 blocks of memory are
allocated by the system, a bit field of length 32 bits is used to represent
each block one to one. If the value of the bit for the corresponding block is a
$1$, then this indicates that the block has been requested by a process. When
the bit is $0$, then the block is somewhere on the free list and can be freely
allocated to a requestor. The enables over-allocation and double-deallocation
checks to be done in $O(1)$ time. The bit is set high (1) when allocated and
set low (0) when released.

\subsection{\textsc{Priority Queues}}
Priority queues are done using a standard queue data structure. The only
difference is that there is a queue for every level of priority. Hence, for the
ready and blocked queues an array of queues is used with the index of the queue
as the priority level. As described earlier, every queue is implemented using a
double-linked list so that nearly every operation occurs in $O(1)$ time.


\section{\textsc{Primitives}}
This section describes the implemenation of major system primitives. These 
primitives are used by the processes for various types of functionality. All 
primitives are implemented as system calls which switch to kernel mode using a 
software interrupt.

\subsection{\textsc{Release Processor}}
The release processor primitive allows the operating system to make a
scheduling decision. Depending on its state, the currently running is
enqueued to either the \texttt{READY}, \texttt{BLOCKED\_MESSAGE}, or
\texttt{BLOCKED\_MEMORY} priority queue. Finally, the unblocked process
of highest priority is dequeued and a context switch is made to it. Pseudo code 
for this primitive is shown in Listing~\ref{releaseproclisting}.

\lstset{caption={Pseudo code for \texttt{release\_processor()}},
        label=releaseproclisting}
\begin{lstlisting}
int release_processor() {
    mode switch to kernel mode using system call exception

    if currently running process is not an i-process:
        enqueue currently running process to appropriate queue

    dequeue next process from highest non-empty priority queue

    context switch to dequeued process
    
    return RTX_SUCCESS
}
\end{lstlisting}

\subsection{\textsc{Set Process Priority}}

The set process priority primitive modifies the priority of a process
in the system. This primitive only accepts valid PIDs and priority
levels. If the updated process is unblocked and has a higher priority
running, then the running is preempted. Listing~\ref{setplisting}
contains pseudo code for this primitive.

\lstset{caption={Pseudo code for \texttt{set\_process\_priority()}},
        label=setplisting}
\begin{lstlisting}
int set_process_priority(int pid, int priority) {
    mode switch to kernel mode using system call exception
    
    if invalid PID or invalid priority:
        return RTX_ERROR
    
    if running process is the process to change:
        update running process to the new priority
    else:
        dequeue process from appropriate queue
        update priority of that process
        enqueue process to its new priority queue

    if the priority of the updated is greater than the running processes priority:
        call release processor

    return RTX_SUCCESS
}
\end{lstlisting}

\subsection{\textsc{Get Process Priority}}
The \texttt{get\_process\_priority()} primitive is used to retrive the
priority of any process in the system. If an invalid PID is specified,
\texttt{RTX\_ERROR} is returned. Otherwise, the PCB is retrieved from
the process table and the priority of the process is returned. Pseudo
code for this primitive can be found in Listing~\ref{getplisting}.

\lstset{caption={Pseudo code for getting the process priority},
        label=getplisting}
\begin{lstlisting}
int get_process_priority(int pid) {
    mode switch to kernel mode using system call exception
    
    if the pid is invalid:
        return RTX_ERROR

    get process from the process table using pid
    
    return process priority
}
\end{lstlisting}

\subsection{\textsc{Request Memory Block}}

The \texttt{request\_memory\_block()} is used by processes to
allocated one of the thirty two memory blocks in the system. All
processes have access to thirty of these blocks, while two are
reserved for usage by i-processes. If no memory blocks are available
to the running process, it becomes blocked on memory and is
preempted. Pseudo code for this primitive is in
Listing~\ref{requestmemory}.

\lstset{caption={Pseudo code for request\_memory\_block()}, label=requestmemory}
\begin{lstlisting}
void* request_memory_block() {
    mode switch to kernel mode using system call exception

    if running process is not an i-process:
        if there are no unreserved memory blocks free:
            set the state of the running process to blocked on memory
            call release processor
    else:
        if there are no memory blocks free:
            set the state of the running process to blocked on memory
            call release processor

    pop block of memory off the free list        
    get block index
    set corresponding bit in memory allocation field to 1

    return address of block
}
\end{lstlisting}

\subsection{\textsc{Release Memory Block}}

\texttt{release\_memory\_block()} is used by processes to deallocate a
previously allocated block of memory. If the block is invalid
\texttt{RTX\_ERROR} is returned. Once the block has been deallocated,
if there are processes blocked on memory, the highest priority blocked
process is unblocked and enqueued to the ready queue. If the priority
of the unblocked process is higher than the running process, the
running process is preempted. Pseudo code for this primitive can be
found in Listing~\ref{releasememory}.

\lstset{caption={Pseudo code for releasing memory blocks}, label=releasememory}
\begin{lstlisting}
int release_memory_block(void* memory_block) {
    mode switch to kernel mode using system call exception

    if memory block is not allocated or out of range:
        return RTX_ERROR
    else:
        push block back on to free list
        set correct bit in memory allocation field to 0

        if there are processes blocked on memory:
            set state of the highest priority blocked process to ready
            if priority of the unblocked is higher than the running process:
                 call release processor

        return RTX_SUCCESS        
}
\end{lstlisting}

\subsection{\textsc{Send Message}}

The \texttt{send\_message()} primitive is used to send a message to a
process in the system. Messages are enqueued onto a message queue in
the receiving process' PCB. If the receiving process is currently
blocked on messages, it is unblocked and enqueued to the ready
queue. If the receiving process is a higher priority than the running
process, the running is preempted. Listing~\ref{sendmsg} contains
pseudo code for this primitive.

\lstset{caption={Pseudo code for sending messages}, label=sendmsg}
\begin{lstlisting}
int send_message(int pid, void* message_envelope){
    mode switch to kernel mode using system call exception

    if pid is invalid:
        return RTX_ERROR

    update sender and receiver fields in message envelope
    enqueue message to message queue of receiving process

    if receiving process is blocked on messages:
        set state of receiving process to ready

    if priority of receiving process is higher than the running process:
        call release processor

    return RTX_SUCCESS
}
\end{lstlisting}

\subsection{\textsc{Receive Message}}

The \texttt{receive\_message()} primitive is used by processes to
receive a message from a process. If a message is available on the
running processes message queue, it is immediately dequeued and
returned. Otherwise, the state of the running process is set to
blocked and it is preempted. Pseudo code for this primitive can be
found in Listing~\ref{receivemsg}.

\lstset{caption={Pseudo code for receive\_message()}, label=receivemsg}
\begin{lstlisting}
void* receive_message(int* sender_id){
    mode switch to kernel mode using system call exception

    while message queue for running process is empty:
        set state of running process to blocked on messages
        call release processor

    dequeue message from message queue of running process
    set sender_id parameter to sender pid found in message envelope
    return message
}
\end{lstlisting}

\subsection{\textsc{Delayed Send}}

The \texttt{delayed\_send()} primitive allows processes to send a
message which will not be delivered until a specified time has
elapsed. The current system time and the delay amount are stored in
the message envelope. The message is then inserted into the delayed
message queue; this queue is ordered such the next to be sent is at
the front. There is only queue for delayed messages, which is shared
between all processes. Sending of the delayed message is handled by
the timer i-process. Pseudo code for this primitive can be found in
Listing~\ref{delay}.

\lstset{caption={Pseudo code for delayed send }, label=delay}
\begin{lstlisting}
int delayed_send(int process_id, void* message_envelope, int delay):
    switch to kernel mode using system call exception

    if receiver pid or delay value is invalid:
        return RTX_ERROR
    else:
        set sender id field of message_envelope
        set receiver id field of message_envelope
        set the delay amount field of message_envelope
        set the send time field of message_envelope
        insert into delayed messages queue

        return RTX_SUCCESS
\end{lstlisting}



\section{\textsc{Processes}}
The operating system consists of several system, user, interrupt, and test 
processes. These processes make up the main functionality of the operating 
system. In order to be implemented properly these processes make use of the 
primitives described above. Processes are assigned different priority levels 
which are used to enforce what process should be running.
\subsection{\textsc{Null Process}}
The process method is defined as an infinite loop that constantly calls 
\texttt{release\_processor()}. It has a priority of four and a process ID of 
zero. This process is outlined in Listing~\ref{nullplisting}.

\lstset{caption={Pseudo code for the null process},
        label=nullplisting}
\begin{lstlisting}
void process_null() {
        repeatedly call release processor
}
\end{lstlisting}

\subsection{\textsc{KCD Process}}
The \texttt{process\_kcd()} handles keyboard input and delegation of keyboard 
commands. Processes can register for commands by sending the 
\texttt{process\_kcd()} a message of a specific type. If a keyboard input 
message is received and a matching command is found the message is forwarded to 
the registered process. The pseudo code for the KCD can been seen in 
Listing~\ref{kcd}.

\lstset{caption={Pseudo code for implementing the KCD Processes}, label=kcd}
\begin{lstlisting}
void process_kcd():
    in an infinite loop:
        receive a message
        if the message type is a keyboard input message:
            if the message body is a registed command:
                send message to registered process
            else:
                release memory block of message
        else if it is a command registration message:
            save the PID and command to be registered
        else:
            release memory block of message
\end{lstlisting}

\subsection{\textsc{CRT Process}}
The \texttt{process\_crt\_display()} blocks until a message is
received. If the type is correct, then the for each character in the message 
data it is sent to the UART shared memory and UART transmit interrupt is 
triggered. Then, the memory of the message is released and released processor is 
called. Pseudo code for the process can be found in Listing~\ref{crt}.

\lstset{caption={Pseudo code for the CRT process}, label=crt}
\begin{lstlisting}
void process_crt_display():
    in an infinite loop:
        receive a message
        if message type is keyboard input or output:
            for each character in the message body:
                write character to uart shared memory
                trigger a uart transmit interrupt
        release memory block of message
        call release processor
    }
}
\end{lstlisting}

\subsection{\textsc{UART I-Process}}

The UART i-process is responsible for handling all UART interrupts,
both receive ready and transmit ready. When the process is run, it
checks which of these interrupts fired. If the interrupt was receive
ready, the input character is appended to a string buffer. When a
keyboard command is detected, it is forwared in a message to the KCD
process. When a hotkey command is detected, the relevant hotkey
command is run. When a transmit interrupt is received, a character is
printed out the UART from a location in shared memory. Pseudo code for
this process can be found in Listing~\ref{uart}.

\lstset{caption={Pseudo code for the UART I-Process}, label=uart}
\begin{lstlisting}
void i_process_uart():
    in an infinite loop:
        determine if the interrupt was receive or transmit

        if the interrupt is receive ready
            read in character

            if the character was a null
                restart loop

            append character to string buffer
            
            if the character was a carriage return:
                append null to string buffer
                
                if the first character in the buffer is '%':
                    request a memory block for a new message
                    copy string buffer into message data field
                    set message type to keyboard input
                    send message to KCD
                else if the first character in the buffer is '!':
                    call uart debug decoder function with string buffer        

            else:
                write the character to uart shared memory
                echo the character by triggering a transmit interrupt

        else if the interrupt is transmit ready:
            write character from uart shared memory to serial port
            mask transmit ready interrupt
            
            if the character is a carriage return:
                print carriage return
                write newline character to uart shared memory
                unmask transmit ready interrupt
            
        release processor
\end{lstlisting}

\subsection{\textsc{Timer I-Process}}

The \texttt{i\_process\_timer()} process runs in response to timer
interrupts, specifically the counter overflow interrupt. Internally,
the process keeps track of the number of milliseconds elapsed since
its start. Whenever the process runs, it is known that a millisecond
has elapsed and the system clock is incremented. Next, any delayed
messages that are ready to be sent are sent to their respective
receiver processes. Pseudo code for this process can be found in
Listing~\ref{timer}.

\lstset{caption={Pseudo code for the Timer I-Process}, label=timer}
\begin{lstlisting}
void i_process_timer():
    set system clock to 0

    in an infinite loop:
        call release processor
        increment system clock

        if delayed messages queue is not empty:
            while the first message in the queue is ready to be sent:
                dequeue the first message
                send message to specified receiver        
\end{lstlisting}

\subsection{\textsc{Wall Clock Process}}
The \texttt{process\_wall\_clock()} is used to display the current
system time on the CRT. The clock is given an initial time when the
\texttt{\%WS} command is received and is updated every second. The
clock is printed until the \texttt{\%WT} command is received.

The clock is updated by repeatedly sending itself messages delayed by
one second. When the clock reaches a time of 24:00:00 it is reset to
00:00:00. Pseudo code for the wall clock process can be found in
Listing~\ref{wallclock}.

\lstset{caption={Pseudo code for the wall clock process}, label=wallclock}
\begin{lstlisting}
void process_wall_clock():
    set the clock to 0

    in an infinite loop:
        receive message

        if the message sender id is the wall clock pid:
            increment clock

            if the clock value is 24 hours:
                reset clock to 0

            if the clock is currently running:
                send ourself a delayed message with a delay of one second
                convert clock to hours, minutes and seconds
                convert hours, minutes, seconds to time string
                send time string as message to CRT

        else if the message sender id is the KCD pid:
            if the command was '%WS':
                if the clock is currently off:
                    send ourself a delayed message with a delay of one second

                parse string and validate input
                set the clock to corresponding input value
                turn clock on
            else if the command was '%WT':
                turn off clock

        release memory block of message
\end{lstlisting}

\subsection{\textsc{Set Priority Command Process}}

The \texttt{process\_set\_priority\_command()} process allows a user
to change the priority of any process in the system directly from
terminal. The process registers the '\%C' keyboard command which takes
the form '\%C pid priority'. When this command is received, the
process parses the arguments, validates them, and if they are correct
it changes the priority of the selected process. Pseudo code for this
process can be found in Listing~\ref{lst_set_prio_cmd_proc}.

\lstset{caption={Pseudo code for the set priority command process}, 
        label=lst_set_prio_cmd_proc}

\begin{lstlisting}
void process_set_priority_command():    
    register '%C' command with KCD process
    
    in an infinite loop:
        receive a message

        skip '%C' in message

        parse process id
        validate process id

        parse priority level
        validate priority level

        validate line endings
        
        call set_process_priority with the provided arguments

        release memory block
        release processor

\end{lstlisting}

\subsection{\textsc{Test Processes A, B, C}}
The system also has three test processes implemented. These processes are used
to stress test our system by depleting memory blocks. \texttt{Process A}
requests a memory block and on receiving one sends a message to \texttt{Process
B}. \texttt{Process B} receives the message and then sends the message to
\texttt{Process C}. \texttt{Process C} then gets a message and checks if the
number of messages it has received is divisible by 20. If it is it prints out
"Process C" to the UART1. Then the process hibernates for 10 seconds. All of
these processes loop forever inorder to deplete memory. In order to have these
processes work properly within our system \texttt{Process C} was assigned a
priority of 1 and the other two processes were assigned a priority of 2.

\section{\textsc{Software Interrupt Handler}}
\label{sec:soft_isr}
% TODO: ADD MORE?

The system uses a single software interrupt handler for performing context
switches into kernel mode for kernel functions. It is initialized in the 0th
location on the trap table. The trap is only called from the function
\texttt{do\_system\_call(int call\_id, int* args, int num\_args)} which is used
to abstract common code used by all the primitives. The software handler itself
that is called by the trap mnemonic is \texttt{system\_call()} which retrieves
the parameters from data registers 1 to 4. It calls the appropriate kernel
level function based on the call id parameter. The call ids are defined in an
enumerator. 

The software interrupt handler, as described in Listing~\ref{lst_system_call},
is installed in vector 0 of the trap table. The operation of this interrupt
handler retrieves the parameters from the data registers, saves the rest of
the user process state into the stack, and calls the appropriate kernel level
function. The parameters retrieved are passed in as arguments for the function.
The function return value is stored in one of the data registers to be passed
back to the function that called the trap. Finally, the function returns from
exception to switch back from kernel mode into user mode.

\lstset{caption={Software Interrupt Handler description},
        label=lst_system_call}
\begin{lstlisting}
void system_call() {
    disable interrupts

    retrieve call id and arguments from data registers

    save current user process state

    use call id to select the appropriate kernel level function 
    pass in the arguments as parameters to the function

    restore user process state

    load return value into a data register

    return from exception
}
\end{lstlisting}

\section{\textsc{Hardware Interrupt Handlers}}
% data structures, functional outline, pseudocode
Two hardware interrupt handlers were implemented. The first is for the timer
interrupts and the second is for the UART for keyboard input from the user.
They both use very similar logic. All of the data and address registers are
moved onto the stack after interrupts are disabled. Then the processor is
preempted with the the respective interrupt process selected as the next
running process. In the case of the timer interrupt, the interrupt event is
acknowledge to prevent the interrupt from firing multiple times for the same
event. After the interrupt process releases the processor, and the processor
returns back to the interrupted process, the data and address registers are
restored from the stack and the interrupt handler returns from the exception.
See Listing~\ref{listing_hwi_handler} for the pseudo code description of the
two interrupt handlers.

\lstset{caption={Hardware Interrupt Handler Pseudo Code},
        label=listing_hwi_handler}
\begin{lstlisting}
void interrupt_handler() {
    disable interrupts
    move data and address registers onto the stack

    acknowledge the interrupt
    preempt processor with the appropriate interrupt process

    restore data and address registers from the stack

    return from exception
}
\end{lstlisting}

Interrupt service routines are loaded into the interrupt vector table and
initialized with the required settings in the initialization period of the
system startup. This is described in Section~\ref{sec:rtx_init}.

\section{\textsc{Hot Keys}}
\label{sec:hot_keys}
% What they are, their functionality, pseudocode 

% TODO: Edit this for tense
A total of five hot key commands were implemented to assist in debugging and
testing of the system and user processes. A hot key decoder function was used to
interpret the inputted command from the UART interrupt process. The interrupt
process checks the first character for an exclamation mark ('!') and calls the
hot key function directly with the input string as a parameter. See
Table~\ref{hot_keys_table} for a summary of the hot key strings and
descriptions. All of the code related to the debug hot keys are wrapped in
\texttt{\#ifdef \_DEBUG\_HOTKEYS} and \texttt{\#endif} to ensure that in normal
operation of the system that this code will not interfere.

\begin{table}[h]
    \caption{Hot Keys and Descriptions}
    \label{hot_keys_table}
    \begin{tabular}{| r | r |}
        \hline
        Hot Key Command & Description \\
        \hline
        !RQ & Print ready processes and priorities \\ 
        !BMQ & Print processes blocked on memory \\ 
        !BRQ & Print processes blocked on receiving messages \\ 
        !FM & Print the current number of free memory blocks \\ 
        !M & Print the last $i$ messages sent where $i$ is the debug message
        log size \\
        \hline
    \end{tabular}
\end{table}

Each of the debugging functions are kernel level calls as they require access
to data structures in the kernel. This is done using the same soft interrupt
method as the the rest of the kernel routines. The hot key command decoder
uses a similar parsing method as the \texttt{process\_wall\_clock()} process to
interrupt which kernel routine to run. The debugging processes related to the
ready queues and blocked queues use the kernel print queue function as
described in Listing~\ref{lsting_k_print_queue}. The specific queue debugging 
function simply passes in the relavent queue into the queue print function.

\lstset{caption={Kernel Print Queue Psuedo Code}, 
        label=lsting_k_print_queue}
\begin{lstlisting}
int queue_debug_print(process_queue queue[]) {
    for each process in the queue:
        print process ID
        print process priority
}
\end{lstlisting}

The hot key, \texttt{!FM}, simply outputs the number of free blocks and the
allocation bit field. The allocation bit field is described in
Section~\ref{sec:mem_management}.

The last hot key, \texttt{!M}, is the most complicated of the five. In each of
the kernel functions related to message sending and receiving, a copy of each
message is stored on a circular buffer that contains a data structure that
maintains a record of the sender ID, receiver ID, message type, the first 16
bytes of data, and the time stamp of the message. Seperate circular buffers are
used for the sent messages and received messages to assist in debugging if a
message has been sent but not received.  When the hot key is called, it goes
through every message in both queues and outputs first all the sent messages
and then all of the received messages. The number of messages store in the two
queues can be changed by modifying the \texttt{DEBUG\_MESSAGE\_LOG\_SIZE}
definition. 

\section{\textsc{Initialization}}
\label{sec:rtx_init}
The RTX initialization happens in four phases: process, priority queues, 
interrupts, and the memory management system. Pseudo code for everything except
memory management can be seen in Listing~\ref{initlisting}.

The process initialization occurs in \texttt{init\_processes()} and is done in
two stages. The first is an initialization of the test processes. Second is the
initialization of the null process and the user processes. For each process, a
PCB is created on the process table. This PCB is then added to the kernel's own
process list but is not yet added to a priority queue. For each process in
the kernel's process list a stack pointer is created and an exception frame is
added to this new stack. The format/vector word portion of the exception frame
is set to 0x4000 to represent a 4 byte aligned stack and the status register
portion is 0x0000. In the frame, the program counter is assigned to the entry
point of the process.

Next, priority queues are initialized. The data structures are already
allocated but not initialized. To ensure proper operation, the queues are
put into a consistent empty state. After the queues are setup, the processes
are added to appropriate queue.

Then interrupts are setup. First, the vector base register (VBR) for the
interrupts is set to memory location 0x10000000. Next, the soft interrupt for
\texttt{system\_call()} is installed to the VBR at vector 0 as outlined in
Section~\ref{sec:soft_isr}.

\lstset{caption={Pseudo code for RTX initialization},label=initlisting}
\begin{lstlisting}
void init() {
    init_processes()
    init_priority_queues()
    init_interrupts()
}

void init_processes() {
    init_test_processes()
    init_user_processes()
    for each process in process list:
        initialize stack pointer
        push PC portion of exception frame onto the stack
        push F/V and SR portions of exception frame onto the stack
}

void init_test_processes() {
    for each test process: 
        setup PCB
        add to process list
}

void init_user_processes() {
    user process list:
        null process
        Process A
        Process B
        Process C
        Uart
        Timer
        CRT
        KCD
        Wall Clock Display
        Set Priority Process

    for each process in user process list:
        setup PCB
        add to process list
}

void init_priority_queues() {
    for each process: 
        add process to correct priority queue
}

void init_interrupts() {
    initialize VBR to 0x10000000
    install system call ISR at vector 0
}
\end{lstlisting}

The final phase of the RTX initialization is memory management.  Memory blocks
are allocated beginning at the start of free memory as defined by the linker.
The function call \texttt{init\_memory(void* memory\_start)}, as seen in
Listing~\ref{meminit}. A free list is used to implement linking and management
of the memory blocks. Over-allocation and double deallocation prevention is
handled by a bit field containing a bit for each memory block. When the memory
is allocated the associated bit is set to 1 and for when it is released it is
set back to 0.

\lstset{caption={Pseudo code for RTX initialization of memory
        management},label=meminit}
\begin{lstlisting}
void init_memory(void* memory_start){
    
    head of memory = start of free memory + (number of memory blocks - 1)*(size of memory block)
    
    for each block in free list:
        store address of next free memory block in current block

    initialize the memory allocation bit field to 0
}
\end{lstlisting}


\section{\textsc{Implementation}}
This section is responsible for outlining some basic implementation techniques 
regarding the testing of our operating system and the measurement of certain 
primitives. It also includes a basic discussion of the role of each group member. 
 
\subsection{\textsc{Responsibilities}}
The majority of the kernel was written as the whole group. The queues, context
switching, and most of the primitives were developed together to ensure that
every group member would have a solid understanding of the operation of the
system. Memory management and message handling was also designed in this
manner. As a result, there were less bugs not only in the primitives but also
in the processes implemented later on by individual members.

\subsubsection{\textsc{Ben Ridder}}
The majority of the processes were implemented by Ben Ridder. He wrote the
hardware interrupt and interrupt process for UART1 paired with the two system
processes, KCD and CRT display, that are associated with it. Hot keys was also
a part of this, with additional changes made to the kernel to create the
desired functionality of the hot keys described in Section~\ref{sec:hot_keys}.
The other system process implemented by Ben was the set priority command
process. User processes A, B, and C were written by Ben as described in the
project documentation. Finally, he wrote boilerplate prior to the next group
session to limit the amount of time spent as a group on it.

\subsubsection{\textsc{Casey Banner}}

\subsubsection{\textsc{David Janssen}}

\subsection{\textsc{Test Plan}}
Testing for the operating system was done in a consistent fashion throughout all
parts of the project. After coding a new process or primitive a new test case 
was written in order to verify its functionality. This test case was then 
implemented using a set of processes which would in turn run these tests. This 
would include tests specifically for memory, messages, the changing of priority, 
etc. Once it was determined that a new addition to the operating was running as 
per specification, the entire test suite was run to verify no negative impact on 
the system. 

To ease the task of debugging, a very basic \texttt{printf} function 
was created which allowed decimal and hexidecimal data to be displayed. This 
was very useful as it allowed us to print the contents of certain registers and 
variables when we were unable easily discover issues when a test case failed or 
functionality was not as expected. 

This testing strategy was not used in part one of the project as it had a 
separate test program written to test its functionality. The user process A, B, 
and C were used to stress test our operating system and verify its behaviour 
under load. 
\subsection{\textsc{Measurement Plan}}
Three methods were considered for profiling the system call
primitives: stopwatch, system millisecond timer, and using a second
hardware timer. In each of these cases, the primitive was run several
thousands times in a loop in order to find an average execution time.

The first method involved manually timing the execution of ten
thousand runs of a particular primitive. A message was printed at the
beginning and the end of the loop and stopwatch was used to measure
the total time elapsed. This method proved ineffective do to inherent
delays in printing.

Second, the system millisecond timer was used to measure the execution
time of the function. This method was not effective because the
millisecond timer did not provide enough granularity in order to get
an accurate result; the average runtime for all primitives was under a
millisecond.

Finally, the second hardware timer was used to measure execution time
of the primitives. By setting the timer to increment its internal
counter at a rate of 180kHz, this profiling method was able to achieve
5.555 microsecond granularity. Using this timer a process was
developed that reset the timer counter register before running a
primitive, and checked its value after the primitive finished
executing. In this fashion the primitive execution time could be
accurately measured.

\chapter{\textsc{Major Design Changes}}

\section{\textsc{Done Queues}}
Initially, the priority queueing system was implemented using several different
queues for various process states and this included a done queue. The purpose
behind the done queue was to ensure that every process would execute in order
from highest to lowest priority. As a result of this system, the demo test
cases failed due to differing expectations of how the scheduling system
operates. These were not clear in the documentation but was clarified at the
demo.

After the demo, the system was changed such that the scheduler would only run
processes in the highest non-empty priority queue. In hindsight, the previous
scheduler would have been ineffective in the requirements of the system for the
last portion of the project. It would have worked better in an environment that
employed time slicing to select the next process periodically.

\section{\textsc{Memory Management}}
Two changes where made to both the implementation of memory and how the
processes used memory blocks. The stress test processes A, B, and C clearly
indicated issues with the original memory system. To ensure consistancy with
the interrupt processes, two memory blocks were set aside just for the UART and
timer processes. Memory management within the system processes also became an
important consideration.

Reserving a couple blocks of memory just for the interrupt processes limited
how often the two interrupt processes became blocked on memory. Blocking the
UART on memory will result in the system appearing like it locked up since
nothing could be inputted from the keyboard or outputted to the display.
Preventing this process from blocking increases the responsiveness of the
system.

From the perspective of the system processes, the initial usage of memory blocks was
naively assuming that a memory block could be requested whenever needed without
worrying about blocking. This was not the case. As a result of this, system processes
would block and create deadlocks for a new memory block as often the process
already had a memory block allocated to it. By reusing memory blocks, processes
would deadlock less often and memory waste was reduced.

\chapter{\textsc{Measurements}}

\chapter{\textsc{Lessons Learned}}

\end{document}
